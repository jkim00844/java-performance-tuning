# Story8. Synchronized 는 제대로 알고 써야 한다.

웹 기반 시스템을 개발할 때는 스레드를 컨트롤할 일은 별로 없으며 만약 스레드를 직접 근드리면 서비스의 안정성이 떨어질 수 있어 자제하는 것이 좋다.

우리가 개발하는 WAS는 여러 개의 스레드가 동작하도록 되어 있다. 그래서 synchronized를 자주 사용한다. 하지만 synchronized를 쓴다고 무조건 안정적인 것은 아니며, 성능에 영향을 미치는 부분도 있다.

**프로세스와 스레드**

클래스를 하나 수행시키거나 WAS를 가동하면, 서버에 자바 프로세스가 하나 생성된다. 하나가 생성되는지 여러 개가 생성되는지는 윈도의 자원관리자나 리눅스, 유닉스의 프로세스를 조회해 보면 된다.

하나의 프로세스에는 여러 개의 스레드가 생성된다. 
단일 스레드가 생성되어 종료될 수도 있고, 여러 개의 스레드가 생성되어 수행될 수도 있다. 
즉 프로세스와 스레드는 일대다 관계이다.
스레드는 Lightweight Process(LWP)라고도 하며 프로세스에서 만들어 사용하고 있는 메모리를 공유한다. 그래서 별개의 프로세스가 하나씩 뜨는 것보다는 성능이나 자원 사용에 있어서 많은 도움이 된다.

**스레드 구현** 

Thread 클래스를 상속하는 방법

Runnable 인터페이스를 구현하는 방법

기본적으로 Thread 클래스는 Runnable 인터페이스를 구현한 것이기 때문에 어느 것을 사용해도 되지만 자바는 다중상속을 지원하지 않으므로 스레드를 구현시 다른 상속 받은 클래스가 있다면 Runnable 인터페이스를 사용하면 된다.

**sleep(), wait(), join() 메서드**

현재 진행 중인 스레드를 대기하도록 하기 위해서 쓰는 세 가지 메서드다.

- sleep() 메서드는 명시된 시간만큼 해당 스레드를 대기시킨다.
    - sleep(long millis): 명시된 ms만큼 해당 스레드가 대기한다. static 메서드이기 때문에 반드시 스레드 객체를 통하지 않아도 사용할 수 있다.
    - sleep(long millis, int nanos): 명시된 ms + 명시된 나노 시간만큼 해당 스레드가 대기한다. 여기서 나노 시간은 0~999999까지 사용할 수 있다. 이 메서드도 위와 마찬가지로 static 메서드다.
- wait() 메서드도 명시된 시간만큼 해당 스레드를 대기시킨다. sleep() 메서드와 다른 점은 매개변수인데, 만약 아무런 매개변수를 지정하지 않으면 notify() 메서드 혹은 notifyAll() 메서드가 호출될 때까지 대기한다.
- join() 메서드는 명시된 시간만큼 해당 스레드가 죽기를 기다린다. 만약 아무런 매개변수를 지정하지 않으면 죽을 때까지 계속 대기한다.

**interrupt(), notify(), notifyAll() 메서드**

앞서 명시한 세 개의 메서드를 '모두' 멈출 수 있는 유일한 메서드는 interrupt() 메서드다. 

interrupt()메서드가 호출되면 중지된 스레드에는 InterruptedException이 발생한다.

- interrupt 메서드는 스레드를 상태를 변경 시킨다.
- isInterrupted메서드는 단지 스레드의 상태만 리턴시킨다.
- isAlive메서드는 스레드가 살아있는지 확인하는 메서드이다.
- notify메서드는 wait()메서드를 멈추기 위한 메서드로 단일 스레드를 깨운다.
- notifyAll메서드는 wait()메서드를 멈추기 위한 메서드로 모든 스레드를 깨운다.

**interrupt() 메서드는 절대적인 것이 아니다**

interrupt()메서드를 호출하여 특정 메서드를 중지시키려고 할 때 항상 해당 메서드가 멈추는 것은 아니다.

interrupt() 메서드는 해당 스레드가 'block'되거나 특정 상태에서만 작동한다.

즉 interrupt()메서드는 대기 상태일 때에만 해당 스레드를 중단시킨다.

**synchronized를 이해하자**

synchronize의 사전적 의미 : 동시에 일어나다. 동시에 진행하다.

하나의 객체에 여러 요청이 동시에 달려들면 원하는 처리를 하지도 못하고 이상한 결과가 나올 수 있다.

그래서 synchronized를 사용해서 동기화를 하는 것이다.

“천천히 한명씩 들어와”라고 해당 메서드나 블록에서 제어하게 된다.

그럼 언제 동기화를 사용해야 할까?

- 하나의 객체를 여러 스레드에서 동시에 사용할 경우
- static으로 선언한 객체를 여러 스레드에서 동시에 사용할 경우

예제)
https://devlog-wjdrbs96.tistory.com/270
 

**동기화를 위해서 자바에서 제공하는 것들**

- Lock: 실행 중인 스레드를 간단한 방법으로 정지시켰다가 실행시킨다. 상호 참조로 인해 발생하는 데드락을 피할 수 있다.
- Executors: 스레드를 더 효율적으로 관리할 수 있는 클래스들을 제공한다. 스레드 풀도 제공하므로, 필요에 따라 유용하게 사용할 수 있다.
- Concurrent 콜렉션: 앞서 살펴본 콜렉션의 클래스들을 제공한다.
- Atomic 변수: 동기화가 되어 있는 변수를 제공한다. 이 변수를 사용하면, synchronized 식별자를 메서드에 지정할 필요 없이 사용할 수 있다.

**JVM 내에서 synchronization은 어떻게 동작할까?**

자바의 HotSpot VM은 '자바 모니터'를 제공함으로써 스레드들이 '상호 배제 프로토콜'에 참여할 수 있도록 돕는다. 자바 모니터는 잠긴 상태나 풀림중 하나이며, 동일한 모니터에 진입한 여러 스레드들 중에서 한 시점에는 단 하나의 스레드만 모니터를 가질 수 있다. 다시 말하면, 모니터를 가진 스레드만 모니터에 의해서 보호되는 영역에 들어가서 작업을 할 수 있다. 여기서 보호된 영역이란 이 장에서 앞서 설명한 synchronized로 감싸진 블록들을 의미한다. 모니터를 보유한 스레드가 보호 영역에서의 작업을 마치면, 모니터는 다른 대기중인 스레드에게 넘어간다.

**정리**

synchronized는 여러 스레드에서 접근하는 것을 막아주는 장점이 있지만 성능 저하가 발생할 수 있다.

성능에 많은 영향을 주는 것은 아니지만 그렇다고 영향이 전혀 없는 것도 아니다.

개발할 때나 기능테스트에서는 문제가 없을 수 있지만 기능을 많이 호출하게 되면 문제가 서서히 노출되고 성능 테스트를 하게 되면 확실히 나타난다. 

따라서 동일한 객체를 공유하거나 static을 사용한 변수를 공유하는 경우에만 사용해야 한다.