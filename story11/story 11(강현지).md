# story 11

# JSP와 Servlet의 기본 동작 원리

## JSP 라이프 사이클

1. JSP URL 호출
2. 페이지 번역
3. JSP 페이지 컴파일
4. 클래스 로드
5. 인스턴스 생성
6. jspInit 메서드 호출
7. _jspService 메서드 호출
8. jspDestory 메서드 호출

해당 JSP 페이지가 이미 컴파일 되어 있고, 클래스가 로드되어 있고, JSP 파일이 변경되지 않았다면, 가장 많은 시간이 소요되는 2~4 프로세스는 생략됨

### Pre-compile 옵션

서버의 종류에 따라 서버가 기동될 때 컴파일을 미리 수행

이 옵션을 선택하면 서버에 최신 버전을 반영한 이후 처음 호출되었을 때 응답 시간이 느린 현상 방지 가능

하지만 개발 시에 이 옵션을 켜 놓으면 서버를 기동할 때마다 컴파일 수행

⇒ 개발 생산성이 떨어지므로 상황에 맞게 옵션 지정

## Servlet 라이프 사이클

WAS의 JVM 시작 후에

- Servlet 객체가 자동으로 생성되고 초기화 되거나
- 사용자가 해당 Servlet을 처음으로 호출했을 때 생성되고 초기화

그 뒤엔 계속 ‘사용 가능’ 상태로 대기

해당 서블릿이 더 이상 필요 없을 때는 ‘파기’ 상태로 넘어간 후 JVM 에서 ‘제거’됨

‼️ 서블릿은 JVM에 여러 객체로 생성되지 않음

⇒ WAS가 시작하고, ‘사용 가능’ 상태가 된 이상 대부분의 서블릿은 JVM에 살아 있고, 여러 스레드에서 해당 서블릿의 service() 메서드를 호출하여 공유

만약 서블릿 클래스에서 멤버 변수를 사용한다면 여러 스레드에서 접근하여 같은 변수를 사용하기 때문에 값이 꼬일 수 있음. 즉, static과 거의 동일한 결과

# 적절한 include 사용

include 기능을 사용하면, 하나의 JSP에서 다른 JSP를 호출하여 여러 JSP 파일을 혼합해서 하나의 JSP로 만들 수 있음

### include 방식

- 정적인 방식
    - JSP의 라이프 사이클 중 JSP 페이지 번역 및 컴파일 단계에서 필요한 JSP를 읽어서 메인 JSP의 자바 소스 및 클래스에 포함 시키는 방식
    - `<%@include file=”관련 URL”%>`
- 동적인 방식
    - 페이지가 호출될 때마다 지정된 페이지를 불러들여서 수행
    - `<jsp:include page=”relativeURL”/>`

**응답 속도**

동적인 방식이 정적인 방식보다 약 30배 더 느림

> 정적인 방식이 더 빠르지만 이 방식을 사용하면 메인 JSP에 추가되는 JSP가 생김
⇒ 추가된 JSP와 메인 JSP에 동일한 이름의 변수가 있으면 심각한 오류 발생할 수 있음
> 

# 자바 빈즈

UI에서 서버 측 데이터를 담아서 처리하기 위한 컴포넌트

자바 빈즈를 통해 useBean을 하면 성능에 많은 영향을 미치지는 않지만, 너무많이 사용하면 JSP에서 소요되는 시간이 증가할 수 있음

```jsx
<jsp:useBean id="list" scope="request" class="java.util.ArrayList" type="java.util.list" />
<jsp:useBean id="count" scope="request" class="java.lang.String"/>
<jsp:useBean id="pageNo" scope="request" class="java.lang.String" />
<jsp:useBean id="pageSize" scope="request" class="java.lang.String" />
...
// 약 20개의 useBean 태그
```

이 화면의 경우 JSP에서 자바 빈즈를 처리하기 위해서 소요된 시간은 전체 응답 시간의 48%에 해당

이 시간을 줄이기 위해서는 TO(Transfer Object) 패턴을 사용해야 함

⇒ 하나의 TO 클래스를 만들고, 위의 예에서 사용된 각 문자열 및 HashMap, List를 그 클래스의 변수로 지정하여 사용

⇒ 한두 개의 자바 빈즈는 상관 없지만, 10~20개의 자바 빈즈를 사용하면 성능에 영향이 있음

# 태그 라이브러리

### 태그 라이브러리란?

JSP에서 공통적으로 반복되는 코드를 클래스로 만들고, 그 클래스를 HTML 태그와 같이 정의된 태그로 사용할 수 있도록 하는 라이브러리

XML 기반의 tld파일과 태그 클래스로 구성

**사용 방법**

web.xml 파일과 tld 파일에 태그 라이브러리와 관련된 내용 지정

일반적으로 태그 라이브러리는 JSP 상단에 지정

```jsx
<%@ tablib uri="tabLibURI" prefix="myPreFix" />
```

내용에 JSP 태그 사용

```jsx
<myPreFix:tabLibSample>
<%=contents%>
</myPreFix:tabLibSample>
```

태그 라이브러리 클래스를 잘못 작성하거나, 클래스로 전송되는 데이터가 많을 때 성능에 문제가 됨

예시)

태그 라이브러리는 태그 사이에 있는 데이터를 넘겨야 하는데, 이때 넘겨주는 데이터 형태는 대부분 문자열 타입

⇒ 데이터가 많을수록 처리해야 하는 내용이 많아짐

⇒ 태그 라이브러리 클래스에서 처리되는 시간이 많아짐

# 스프링 프레임워크

## 핵심 기술

1. Dependency Injection
    
    객체 간의 의존 관계를 관리하는 기술
    
    어떤 객체가 필요로 하는 객체를 자기 자신이 직접 생성하여 사용하는 것이 아니라 외부에 있는 다른 무언가로부터 필요로 하는 객체를 주입 받는 기술
    
    ```java
    public class A {
    	private B b = new B();
    }
    ```
    
    A 클래스는 항상 B 클래스의 객체를 사용
    
    ⇒ 나중에 B라는 객체를 다른 것으로 교체하기 어려움
    
    ```java
    public class A {
    	private B b;
    	public A(B b) {
    		this.b = b;
    	}
    }
    ```
    
    B 클래스의 객체를 외부에서 넘기는 형태로 코드를 작성하면 A클래스가 사용하는 객체를 다른것으로 변경 가능
    
    ⇒ A 클래스의 객체를 사용하기 전에 필요한 B 객체를 외부에서 미리 만들어서 넘겨 줄 수 있는 구조
    
    스프링은 의존성을 쉽게 주입하는 틀을 제공
    
    - XML이나 어노테이션 등으로 의존성을 주입하는 방법 제공
    - 생성자 주입, 세터 주입, 필드 주입 등 다양한 의존성 주입 방법 제공

1. Aspect Oriented Programming(AOP)
    
    관점 지향 프로그래밍
    
    OOP를 더 OOP스럽게 보완해주는 기술
    
    트랜잭션, 로깅, 보완 체크 같은 코드들을 비즈니스 로직과 분리할 수 있도록 도와줌
    
    - AspectJ : 자바에서 가장 유명한 AOP 프레임워크
    
    스프링에서는 AspectJ 보다 사용하기 간편한 방법을 사용한 스프링 AOP 제공
    
2. Portable Service Abstraction(PSA)
    
    스프링은 비슷한 기술을 모두 아우를 수 있는 추상화 계층 제공
    
    사용하는 기술이 바뀌더라도 비즈니스 로직의 변화가 없도록 도와줌
    
    예를 들어 트랜잭션 처리를 하고 싶을 때 사용하는 기술에 따라 JDBC, iBatis, Hibernate, JTAf의 API를 사용하여 트랜잭션 처리 코드를 작성해야 하는데 비슷한 기술을 구현하기 위해 사용하는 라이브러리나 프레임워크에 따라 코드가 달라지기 때문에 추상화가 매우 중요함
    

## 스프링 프레임워크를 사용하면서 발생할 수 있는 문제점들

1. 스프링 프레임워크를 사용할 때 성능 문제가 가장 많이 발생하는 부분은 ‘프록시’와 관련되어 있음

스프링 프록시는 기본적으로 실행 시에 생성됨

요청량이 많은 운영 상황에서 문제가 나타날 수 있음

@Transactional 어노테이션을 사용하면 해당 어노테이션을 사용한 클래스의 인스턴스를 처음 만들 때 프록시 객체 생성

개발자가 직접 스프링 AOP를 사용해서 별도의 기능을 추가하는 경우에도 프록시를 사용하는데 개발자가 직접 작성한 AOP 코드는 예상하지 못한 성능 문제를 보일 가능성이 높아서 성능 테스트를 간단하게라도 해야함

1. 스프링 내부 매커니즘에서 사용하는 캐시도 조심해야함

```java
@RequestMapping("/member/{id}")
public String hello(@PathVariable int id) {
	return "redirect:/member/"+id;
}
```

이런 코드에서 문자열 자체를 리턴하면 해당 문자열에 해당하는 실제 뷰 객체를 찾는 메커니즘 사용

⇒ 뷰 객체를 캐싱해두면 동일한 문자열이 반환됐을 때 훨씬 빠름

매번 다른 문자열이 생성될 가능성이 높다면 문자열을 반환하는게 메모리에 치명적일 수 있기때문에 뷰 객체 자체를 반환하는 방법이 좋음

참고

[https://tailerbox.tistory.com/42](https://tailerbox.tistory.com/42)